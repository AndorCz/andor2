drop table if exists profiles cascade;
drop table if exists threads cascade;
drop table if exists games cascade;
drop table if exists characters cascade;
drop table if exists posts cascade;
drop table if exists reactions cascade;
drop table if exists messages cascade;
drop table if exists boards cascade;
drop table if exists bookmarks cascade;
drop table if exists maps cascade;
drop table if exists news cascade;

drop type if exists character_state;
drop type if exists game_system;
drop type if exists game_category;
drop type if exists work_type cascade;
drop type if exists work_tag cascade;
drop type if exists work_category cascade;
drop type if exists post_content_type;

drop view if exists posts_owner;
drop view if exists discussion_posts_owner;
drop view if exists game_posts_owner;
drop view if exists board_list;
drop view if exists game_list;
drop view if exists work_list;
drop view if exists last_posts;
drop view if exists game_messages;
drop view if exists user_bookmarks;


-- EXTENSIONS --------------------------------------------


create extension if not exists pg_cron;
select cron.schedule('trim-chat', '0 5 * * *', $$select delete_old_chat_posts()$$);

create extension if not exists citext;


-- ENUMS --------------------------------------------


create type character_state as enum ('alive', 'unconscious', 'dead', 'deleted');
create type game_system as enum ('base', 'vampire5', 'yearzero', 'dnd5', 'drd1', 'cyberpunk', 'starwars', 'cthulhu', 'warhammer', 'shadowrun', 'pathfinder', 'mutant', 'gurps', 'fate', 'savage', 'dungeonworld', 'onering', 'other');
create type game_category as enum ('anime', 'cyberpunk', 'detective', 'based', 'fantasy', 'furry', 'history', 'horror', 'comedy', 'scifi', 'steampunk', 'strategy', 'survival', 'urban', 'relationship', 'other');
create type game_tag as enum ( 'adventure', 'combat', 'detective', 'mystery', 'social', 'strategy', 'horror', 'romance', 'humor', 'scifi', 'postapo', 'dark', 'fantasy', 'historical', 'mature', 'other' )
create type work_type as enum ('text', 'image', 'audio');
create type work_tag as enum ( 'story', 'continued', 'preview', 'thought', 'fanfiction', 'scifi', 'fantasy', 'mythology', 'horror', 'detective', 'romance', 'fairytale', 'dystopia', 'humorous', 'fromlife', 'motivational', 'biography', 'gameworld', 'gamematerial', 'editorial', 'announcement', 'project', 'erotica', 'portrait', 'landscape', 'abstract', 'guitar', 'piano', 'orchestral', 'electronic' );
create type work_category as enum ( 'prose', 'poetry', 'game', 'painting', 'drawing', 'photo', 'digital', 'instrumental', 'vocal', 'ambient', 'other' );
create type post_content_type as enum ('game', 'other');


-- TABLES --------------------------------------------


create table profiles (
  id uuid not null primary key,
  name citext unique not null,
  portrait text,
  created_at timestamp with time zone default current_timestamp,
  last_activity timestamp with time zone,
  old_id int4,
  theme text default 'obsidian',
  solo_limit int4 default 5,
  autorefresh boolean default false,
  -- editor_bubble boolean default false,
  colors text[] default '{}',
  constraint profiles_id_fkey foreign key (id) references auth.users(id) on delete cascade
);

create table threads (
  id int4 not null primary key generated by default as identity,
  name text,
  created_at timestamp with time zone default current_timestamp
);

create table games (
  id int4 not null primary key generated by default as identity,
  name text unique not null,
  owner uuid not null default auth.uid(),
  annotation text,
  recruitment text,
  prompt text,
  story text,
  notes text,
  system public.game_system not null default 'base'::game_system,
  category public.game_category not null default 'other'::game_category,
  discussion_thread int4,
  recruitment_open boolean not null default true,
  open_codex boolean not null default true,
  open_game boolean not null default true,
  open_discussion boolean not null default false,
  open_chars boolean not null default true,
  game_thread int4,
  openai_thread text,
  openai_storyteller text,
  custom_header text,
  active_map integer,
  welcome_message text default 'Vítej v naší hře!'::text,
  context_dice boolean not null default true,
  fonts text[] default '{}',
  archived boolean default false,
  published boolean default false,
  created_at timestamp with time zone default current_timestamp,
  info_changed_at timestamp with time zone default current_timestamp,
  characters_changed_at timestamp with time zone default current_timestamp,
  constraint games_owner_fkey foreign key (owner) references profiles(id) on delete restrict,
  constraint games_discussion_thread_fkey foreign key (discussion_thread) references threads(id),
  constraint games_game_thread_fkey foreign key (game_thread) references threads (id)
);

create table solo_concepts (
  id int4 not null primary key generated by default as identity,
  author uuid not null,
  name text not null,
  annotation text,
  custom_header text,
  storyteller uuid,
  protagonist_names text[],
  prompt_world text,
  prompt_protagonist text,
  prompt_locations text,
  prompt_factions text,
  prompt_characters text,
  prompt_plan text,
  prompt_header_image text,
  prompt_storyteller_image text,
  generated_world text,
  generated_locations text,
  generated_factions text,
  generated_characters text,
  generated_protagonist text,
  generated_plan text,
  generated_header_image text,
  generated_storyteller_image text,
  tags public.game_tag[] default '{}'::public.game_tag[],
  game_count int4 default 0,
  upvotes int4 default 0,
  generating text[] not null default '{}',
  published boolean default false,
  created_at timestamp with time zone default current_timestamp,
  updated_at timestamp with time zone default current_timestamp,
  constraint solo_concepts_st_fkey foreign key (storyteller) references npcs(id) on delete set null,
  constraint solo_concepts_author_fkey foreign key (author) references profiles(id) on delete cascade
);

create table solo_games (
  id uuid not null primary key generated by default as identity,
  concept_id int4 not null,
  name text not null,
  player uuid not null,
  thread int4,
  created_at timestamp with time zone default current_timestamp,
  constraint solo_games_concept_fkey foreign key (concept_id) references solo_concepts(id) on delete cascade,
  constraint solo_games_player_fkey foreign key (player) references profiles(id) on delete cascade,
  constraint solo_games_thread_fkey foreign KEY (thread) references threads (id) on update CASCADE on delete CASCADE
);

create table codex_sections (
  id int4 not null primary key generated by default as identity,
  game int4 not null,
  name text not null,
  slug text not null,
  hidden boolean not null default false,
  index smallint default 0,
  content text,
  created_at timestamp with time zone default current_timestamp,
  constraint codex_game_fkey foreign key (game) references games (id) on delete cascade
);

create table codex_pages (
  id int4 not null primary key generated by default as identity,
  game int4 not null,
  section int4 null,
  name text not null,
  slug text not null,
  content text,
  index smallint default 0,
  hidden boolean not null default false,
  created_at timestamp with time zone default current_timestamp,
  updated_at timestamp with time zone default current_timestamp,
  constraint codex_game_fkey foreign key (game) references games (id) on delete cascade,
  constraint codex_sections_fkey foreign key (section) references codex_sections (id) on delete cascade
);

create table maps (
  id int4 not null primary key generated by default as identity,
  game int4 not null,
  name text not null,
  image text not null,
  description text,
  hidden boolean,
  fow boolean not null default false,
  fow_image text,
  characters json not null default '{}',
  propositions json not null default '{}',
  created_at timestamp with time zone default current_timestamp,
  updated_at timestamp with time zone default current_timestamp,
  constraint maps_game_fkey foreign key (game) references games (id) on delete cascade
);

alter table games add constraint games_active_map_fkey foreign key (active_map) references maps (id) on delete set null;

create table boards (
  id int4 not null primary key generated by default as identity,
  name text unique not null,
  annotation text,
  header text,
  thread int4,
  owner uuid not null default auth.uid(),
  open boolean not null default true,
  mods uuid[] default '{}'::uuid[],
  bans uuid[] default '{}'::uuid[],
  members uuid[] default '{}'::uuid[],
  custom_header text,
  published boolean default false,
  created_at timestamp with time zone default current_timestamp,
  constraint boards_owner_fkey foreign key (owner) references profiles(id) on delete restrict,
  constraint boards_thread_fkey foreign key (thread) references threads(id)
);

create table characters (
  id uuid not null primary key default gen_random_uuid(),
  game int4,
  solo_game uuid null,
  player uuid,
  portrait text,
  name text,
  bio text,
  appearance text,
  color text,
  storyteller_notes text,
  storyteller boolean not null default false,
  open boolean not null default false,
  accepted boolean not null default false,
  created_at timestamp with time zone default current_timestamp,
  state public.character_state not null default 'alive'::character_state,
  constraint characters_game_fkey foreign KEY (game) references games (id) on delete set null,
  constraint characters_player_fkey foreign KEY (player) references profiles (id) on delete CASCADE,
  constraint characters_solo_game_fkey foreign KEY (solo_game) references solo_games (id) on delete CASCADE,
  constraint characters_name_check check ((length(name) < 50))
);

create table npcs (
  id uuid not null primary key default gen_random_uuid(),
  slug text not null,
  solo_game uuid,
  solo_concept int4,
  portrait text,
  name text,
  bio text,
  appearance text,
  storyteller_notes text,
  storyteller boolean not null default false,
  state public.character_state not null default 'alive'::character_state,
  created_at timestamp with time zone default current_timestamp,
  constraint npcs_solo_concept_fkey foreign key (solo_concept) references solo_concepts (id) on delete cascade,
  constraint npcs_solo_game_fkey foreign key (solo_game) references solo_games (id) on delete cascade
);

create table works (
  id int4 not null primary key generated by default as identity,
  type public.work_type not null default 'text'::work_type,
  owner uuid not null,
  name text not null,
  annotation text,
  content text not null,
  thread int4,
  custom_header text,
  category public.work_category not null default 'other'::work_category,
  tags public.work_tag[] default '{}'::public.work_tag[],
  likes uuid[] default '{}'::uuid[],
  dislikes uuid[] default '{}'::uuid[],
  reports uuid[] default '{}'::uuid[],
  editorial boolean default false,
  published boolean default false,
  created_at timestamp with time zone default current_timestamp,
  constraint works_owner_fkey foreign key (owner) references profiles (id) on delete set null
);

create table posts (
  id int4 not null primary key generated by default as identity,
  thread int4,
  owner uuid,
  owner_type text not null,
  post_type public.post_content_type not null default 'other'::public.post_content_type,
  content text,
  important boolean default false,
  audience uuid[],
  note text,
  moderated boolean default false,
  dice boolean default false,
  created_at timestamp with time zone default current_timestamp,
  updated_at timestamp with time zone default current_timestamp,
  constraint posts_thread_fkey foreign key (thread) references threads (id) on delete cascade
);

create table reactions (
  item_id int4 not null,
  item_type text not null check (item_type in ('post', 'news')),
  thumbs uuid[] default '{}'::uuid[],
  frowns uuid[] default '{}'::uuid[],
  shocks uuid[] default '{}'::uuid[],
  hearts uuid[] default '{}'::uuid[],
  laughs uuid[] default '{}'::uuid[],
  constraint unique_item unique (item_id, item_type)
);

create table messages (
  id int4 not null primary key generated by default as identity,
  sender_user uuid,
  recipient_user uuid,
  sender_character uuid,
  recipient_character uuid,
  content text,
  moderated boolean default false,
  created_at timestamp with time zone default current_timestamp,
  updated_at timestamp with time zone default current_timestamp,
  constraint messages_sender_user_fkey foreign key (sender_user) references profiles (id) on delete cascade,
  constraint messages_recipient_user_fkey foreign key (recipient_user) references profiles (id) on delete cascade,
  constraint messages_sender_character_fkey foreign key (sender_character) references characters (id) on delete cascade,
  constraint messages_recipient_character_fkey foreign key (recipient_character) references characters (id) on delete cascade
);

-- Tables for aggregated unread message counts and read timestamps
create table read_user_conversations (
  reader_user_id uuid not null,
  peer_user_id uuid not null,
  read_at timestamptz not null default current_timestamp,
  primary key (reader_user_id, peer_user_id),
  foreign key (reader_user_id) references profiles(id) on delete cascade,
  foreign key (peer_user_id) references profiles(id) on delete cascade,
  check (reader_user_id <> peer_user_id)
);

create table unread_user_message_counts (
  recipient_user_id uuid not null,
  sender_user_id uuid not null,
  unread_count integer not null default 0,
  primary key (recipient_user_id, sender_user_id),
  foreign key (recipient_user_id) references profiles(id) on delete cascade,
  foreign key (sender_user_id) references profiles(id) on delete cascade,
  check (recipient_user_id <> sender_user_id)
);

create table read_character_conversations (
  reader_character_id uuid not null,
  peer_character_id uuid not null,
  read_at timestamptz not null default current_timestamp,
  primary key (reader_character_id, peer_character_id),
  foreign key (reader_character_id) references characters(id) on delete cascade,
  foreign key (peer_character_id) references characters(id) on delete cascade,
  check (reader_character_id <> peer_character_id)
);

create table unread_character_message_counts (
  recipient_character_id uuid not null,
  sender_character_id uuid not null,
  unread_count integer not null default 0,
  primary key (recipient_character_id, sender_character_id),
  foreign key (recipient_character_id) references characters(id) on delete cascade,
  foreign key (sender_character_id) references characters(id) on delete cascade,
  check (recipient_character_id <> sender_character_id)
);

create table bookmarks (
  id int4 not null primary key generated by default as identity,
  user_id uuid,
  game_id int4,
  board_id int4,
  work_id int4,
  solo_id uuid,
  game_main_thread int4 null references threads(id) on delete set null,
  game_discussion_thread int4 null references threads(id) on delete set null,
  board_thread int4 null references threads(id) on delete set null,
  work_thread int4 null references threads(id) on delete set null,
  index smallint default 0,
  created_at timestamp with time zone default current_timestamp,
  constraint unique_user_game unique (user_id, game_id),
  constraint unique_user_board unique (user_id, board_id),
  constraint unique_user_work unique (user_id, work_id),
  constraint unique_user_solo unique (user_id, solo_id),
  constraint bookmarks_work_id_fkey foreign key (work_id) references works (id) on delete cascade,
  constraint bookmarks_game_id_fkey foreign key (game_id) references games (id) on delete cascade,
  constraint bookmarks_board_id_fkey foreign key (board_id) references boards (id) on delete cascade,
  constraint bookmarks_solo_id_fkey foreign key (solo_id) references solo_games (id) on delete cascade,
  constraint bookmarks_user_id_fkey foreign key (user_id) references profiles (id) on delete cascade
);

create table read_threads (
  user_id uuid not null,
  thread_id int4 not null,
  read_at timestamp with time zone not null default current_timestamp,
  foreign key (user_id) references profiles (id) on delete cascade,
  foreign key (thread_id) references threads (id) on delete cascade,
  primary key (user_id, thread_id)
);

create table unread_threads (
  id int4 not null primary key generated by default as identity,
  user_id uuid not null references profiles(id) on delete cascade,
  thread_id int4 not null references threads(id) on delete cascade,
  unread_count int4 not null default 0,
  constraint unique_user_thread unique (user_id, thread_id)
);

create table subscriptions (
  id int4 not null primary key generated by default as identity,
  user_id uuid not null,
  game int4 not null,
  notification boolean default false,
  email boolean default false,
  created_at timestamp with time zone default current_timestamp,
  constraint subscriptions_user_id_fkey foreign key (user_id) references profiles (id) on delete cascade,
  constraint subscriptions_game_id_fkey foreign key (game_id) references games (id) on delete cascade,
  constraint subscriptions_user_game_unique unique (user_id, game)
);

create table news (
  id int4 not null primary key generated by default as identity,
  title text not null,
  content_type text not null, -- types: 'game', 'work', 'board', 'text', 'post'
  content_id int4,
  image_url text,
  subheadline text,
  button_text text,
  url text,
  content text not null,
  published boolean default false,
  owner uuid;
  character uuid,
  character_name text,
  created_at timestamp with time zone default current_timestamp;
  constraint news_owner_fkey foreign key (owner) references profiles (id) on delete cascade
);

create table contacts (
  owner uuid not null references public.profiles(id) on delete cascade,
  contact_user uuid not null references public.profiles(id) on delete cascade,
  created_at timestamptz default now(),
  primary key(owner, contact_user)
);


-- VIEWS --------------------------------------------


create or replace view news_reactions as
  select n.id, n.title, n.content_type, n.content_id, n.image_url, n.subheadline, n.button_text, n.url, n.content, n.published, n.owner, p.id as owner_id, p.name as owner_name, p.portrait as owner_portrait, n.character, n.character_name, n.created_at, r.thumbs, r.frowns, r.shocks, r.hearts, r.laughs
  from news n
  left join reactions r
  on n.id = r.item_id and r.item_type = 'news'
  left join profiles p
  on n.owner = p.id;


create or replace view discussion_posts_owner as
  select
    p.*,
    case
      when p.owner_type = 'user' then profiles.name
      when p.owner_type = 'character' then characters.name
    end as owner_name,
    case
      when p.owner_type = 'user' then profiles.portrait
      when p.owner_type = 'character' then characters.portrait
    end as owner_portrait,
    reactions.*
  from
    posts p
    left join profiles on p.owner = profiles.id and p.owner_type = 'user'
    left join characters on p.owner = characters.id and p.owner_type = 'character'
    left join reactions on p.id = reactions.item_id and reactions.item_type = 'post'
  order by p.created_at desc;


create or replace view posts_owner as
  select
    p.*,
    case
      when p.owner_type = 'user' then profiles.name
      when p.owner_type = 'character' then characters.name
      when p.owner_type = 'npc' then npcs.name
    end as owner_name,
    case
      when p.owner_type = 'user' then profiles.portrait
      when p.owner_type = 'character' then characters.portrait
      when p.owner_type = 'npc' then npcs.portrait
    end as owner_portrait,
    get_character_names (p.audience) as audience_names,
    reactions.*
  from
    posts p
    left join profiles on p.owner = profiles.id and p.owner_type = 'user'
    left join characters on p.owner = characters.id and p.owner_type = 'character'
    left join reactions on p.id = reactions.item_id and reactions.item_type = 'post'
    left join npcs on p.owner = npcs.id and p.owner_type = 'npc'
  order by p.created_at desc;


create or replace view game_posts_owner as
  select
    p.id, p.thread, p.owner, p.owner_type, p.content, p.audience, p.openai_post, p.moderated, p.dice, p.created_at, p.updated_at, p.important,
    characters.name as owner_name,
    characters.portrait as owner_portrait,
    games.id as game_id
  from posts p join games on p.thread = games.game_thread left join characters on p.owner = characters.id
  where games.id is not null
  order by p.created_at desc;


create or replace view board_list as
  select b.*, pr.id as owner_id, pr.name as owner_name, pr.portrait as owner_portrait, count(p.id) as post_count, max(p.created_at) as last_post
  from boards b
    left join threads t on b.thread = t.id
    left join profiles pr on b.owner = pr.id
    left join posts p on t.id = p.thread
  group by b.id, pr.id, pr.name
  order by b.created_at desc;


create or replace view game_list as
  select g.*, pr.id as owner_id, pr.name as owner_name, pr.portrait as owner_portrait, count(p.id) as post_count, max(p.created_at) as last_post
  from games g
    left join threads t on g.game_thread = t.id
    left join profiles pr on g.owner = pr.id
    left join posts p on t.id = p.thread
  group by g.id, pr.id, pr.name
  order by g.created_at desc;


create or replace view work_list as
  select w.*, pr.id as owner_id, pr.name as owner_name, pr.portrait as owner_portrait, count(p.id) as post_count
  from works w
    left join threads t on w.thread = t.id
    left join profiles pr on w.owner = pr.id
    left join posts p on t.id = p.thread
  group by w.id, pr.id, pr.name
  order by w.created_at desc;


create or replace view game_messages as
  select messages.id, messages.sender_user, messages.recipient_user, messages.content, messages.read, messages.moderated, messages.created_at, messages.sender_character, messages.recipient_character
  from messages
  where messages.sender_character is not null and messages.recipient_character is not null;


create or replace view public.user_bookmarks as
select
  b.id as bookmark_id,
  b.user_id,
  b.game_id,
  b.board_id,
  b.work_id,
  b.solo_id,
  b.game_main_thread,
  b.game_discussion_thread,
  b.board_thread,
  b.work_thread,
  b.index,
  b.created_at as bookmark_created_at,
  COALESCE(g.name, brd.name, w.name, s.name) as name,
  COALESCE(ut_main.unread_count, ut_board.unread_count, ut_work.unread_count, 0) as unread,
  COALESCE(ut_disc.unread_count, 0) as unread_secondary
from bookmarks b
  left join games g on b.game_id = g.id
  left join boards brd on b.board_id = brd.id
  left join works w on b.work_id = w.id
  left join solo_games s on b.solo_id = s.id
  left join unread_threads ut_main on b.game_main_thread = ut_main.thread_id and b.user_id = ut_main.user_id
  left join unread_threads ut_disc on b.game_discussion_thread = ut_disc.thread_id and b.user_id = ut_disc.user_id
  left join unread_threads ut_board on b.board_thread = ut_board.thread_id and b.user_id = ut_board.user_id
  left join unread_threads ut_work on b.work_thread = ut_work.thread_id and b.user_id = ut_work.user_id
where b.user_id = (select auth.uid());


-- FUNCTIONS --------------------------------------------


create or replace function get_affected_users_for_post_change (p_thread_id int4, p_post_owner_id uuid, p_post_owner_type text, p_post_type public.post_content_type, p_post_audience uuid[]) returns setof uuid as $$
declare
  v_post_owner_actual_user_id uuid;
begin
  -- resolve the actual user_id of the post owner
  if p_post_owner_type = 'character' then
    select c.player into v_post_owner_actual_user_id from characters c where c.id = p_post_owner_id;
  else
    v_post_owner_actual_user_id := p_post_owner_id;
  end if;
  if p_post_type = 'game' then
    if p_post_audience is not null and array_length(p_post_audience, 1) > 0 then
      -- Game post with a specific character audience.
      return query
      select distinct ch.player
      from characters ch
      where ch.id = any(p_post_audience) and ch.player is not null and ch.player != v_post_owner_actual_user_id;
    else
      -- Public game post (no specific audience).
      return query
      select distinct ch.player
      from games g
      join characters ch on ch.game = g.id
      -- Assuming 'game' type posts are in either the game_thread or discussion_thread of a game.
      where (g.game_thread = p_thread_id or g.discussion_thread = p_thread_id)
        and ch.player is not null
        and ch.player != v_post_owner_actual_user_id;
    end if;
  else
    -- For these post types, affect users who have previously read this thread.
    return query
    select rt.user_id
    from read_threads rt
    where rt.thread_id = p_thread_id and rt.user_id != v_post_owner_actual_user_id;
  end if;
  return;
end;
$$ language plpgsql;


create or replace function increment_unread_counters () returns trigger as $$
declare
  affected_users record;
begin
  for affected_users in
    select user_id
    from get_affected_users_for_post_change(new.thread, new.owner, new.owner_type, new.post_type, new.audience)
  loop
    insert into unread_threads (user_id, thread_id, unread_count)
    values (affected_users.user_id, new.thread, 1)
    on conflict (user_id, thread_id) do update
    set unread_count = unread_threads.unread_count + 1;
  end loop;
  return new;
end;
$$ language plpgsql;


create or replace function decrement_unread_counters () returns trigger as $$
declare
  affected_user_id uuid;
  v_user_read_at timestamp with time zone;
begin
  for affected_user_id in
    select user_id from get_affected_users_for_post_change( old.thread, old.owner, old.owner_type, old.post_type, old.audience ) as user_id
  loop
    -- Get the last time this affected user read this specific thread
    select rt.read_at into v_user_read_at
    from read_threads rt
    where rt.user_id = affected_user_id and rt.thread_id = old.thread;
    if v_user_read_at is null or old.created_at > v_user_read_at then
      update unread_threads
      set unread_count = greatest(0, unread_threads.unread_count - 1)
      where unread_threads.user_id = affected_user_id
        and unread_threads.thread_id = old.thread;
    end if;
  end loop;
  return old;
end;
$$ language plpgsql;


create or replace function get_unread_tabs () returns json as $$
declare
  unread_bookmarks boolean;
  unread_user_messages boolean;
  unread_character_messages boolean;
  current_user_id uuid := auth.uid();
begin
  select exists(select 1 from user_bookmarks where (unread > 0 or unread_secondary > 0)) into unread_bookmarks;
  select exists(select 1 from unread_user_message_counts uumc where uumc.recipient_user_id = current_user_id and uumc.unread_count > 0) into unread_user_messages;
  select exists(select 1 from unread_character_message_counts ucmc join characters c on ucmc.recipient_character_id = c.id where c.player = current_user_id and ucmc.unread_count > 0) into unread_character_messages;
  return json_build_object( 'unread_bookmarks', unread_bookmarks, 'unread_user_messages', unread_user_messages, 'unread_character_messages', unread_character_messages );
end;
$$ language plpgsql;


create or replace function add_storyteller () returns trigger as $$
begin
  insert into characters (name, game, player, accepted, storyteller) values ('Vypravěč', new.id, new.owner, true, true);
  return new;
end;
$$ language plpgsql;


create or replace function take_over_character (character_id uuid) returns uuid as $$
declare
  character_row characters%ROWTYPE;
begin
  select * into character_row from characters where id = character_id;
  if is_storyteller(character_row.game) is false then raise exception 'Nejsi vypravěč'; end if;
  -- create a new character with the same data for the player to keep (except for the game columns)
  character_row.id := gen_random_uuid();
  character_row.game := null;
  character_row.accepted := false;
  character_row.storyteller := false;
  insert into characters values (character_row.*);
  -- update the original character to change the player
  update characters set player = auth.uid() where id = character_id;
  return character_row.id;
end;
$$ language plpgsql security definer;


create or replace function add_game_threads () returns trigger as $$
begin
  insert into threads (name) values (new.name || ' - discussion') returning id into new.discussion_thread;
  insert into threads (name) values (new.name || ' - game') returning id into new.game_thread;
  insert into read_threads (user_id, thread_id, read_at) values (auth.uid(), new.discussion_thread, now()) on conflict (user_id, thread_id) do nothing;
  insert into unread_threads (user_id, thread_id, unread_count) values (auth.uid(), new.discussion_thread, 0) on conflict (user_id, thread_id) do nothing;
  insert into read_threads (user_id, thread_id, read_at) values (auth.uid(), new.game_thread, now()) on conflict (user_id, thread_id) do nothing;
  insert into unread_threads (user_id, thread_id, unread_count) values (auth.uid(), new.game_thread, 0) on conflict (user_id, thread_id) do nothing;
  return new;
end;
$$ language plpgsql;


create or replace function delete_game_threads () returns trigger as $$
begin
  delete from threads where id = old.discussion_thread;
  delete from threads where id = old.game_thread;
  return old;
end;
$$ language plpgsql;


create or replace function add_thread () returns trigger as $$
begin
  insert into threads (name) values (new.name) returning id into new.thread;
  insert into read_threads (user_id, thread_id, read_at) values (auth.uid(), new.thread, now()) on conflict (user_id, thread_id) do nothing;
  insert into unread_threads (user_id, thread_id, unread_count) values (auth.uid(), new.thread, 0) on conflict (user_id, thread_id) do nothing;
  return new;
end;
$$ language plpgsql;


create or replace function delete_thread () returns trigger as $$
begin
  delete from threads where id = old.thread;
  return old;
end;
$$ language plpgsql;


create or replace function add_codex_index () returns trigger as $$
begin
  insert into codex_pages (game, name, slug) values (new.id, 'Úvod', 'index');
  return new;
end;
$$ language plpgsql security definer;


create or replace function reject_character (character_id uuid) returns void as $$
begin
  if not is_players_character(character_id) and not is_storyteller((select game from characters where id = character_id)) then raise exception 'Nejsi vypravěč hry, ani vlastník postavy'; end if;
  update characters set game = null, accepted = false where id = character_id;
end;
$$ language plpgsql security definer;


create or replace function claim_character (character_id uuid) returns void as $$
declare
  character_row characters%ROWTYPE;
begin
  select * into character_row from characters where id = character_id;
  if character_row.open is false then raise exception 'Postava není volná'; end if;
  update characters set player = auth.uid(), open = false where id = character_id;
end;
$$ language plpgsql security definer;


create or replace function hand_over_character (character_id uuid, new_owner uuid) returns uuid as $$
declare
  character_row characters%ROWTYPE;
begin
  select * into character_row from characters where id = character_id;
  if auth.uid() != character_row.player then raise exception 'Není tvoje postava'; end if;
  -- create a new character with the same data for the player to keep (except for the game columns)
  character_row.id := gen_random_uuid();
  character_row.game := null;
  character_row.accepted := false;
  character_row.storyteller := false;
  insert into characters values (character_row.*);
  -- update the original character to change the player
  update characters set player = new_owner where id = character_id;
  return character_row.id;
end;
$$ language plpgsql security definer;


create or replace function get_character_names (audience_ids uuid[]) returns text[] as $$
declare
  names text[];
begin
  select array_agg(name) into names from unnest(audience_ids) as audience_id join characters on characters.id = audience_id;
  return names;
end;
$$ language plpgsql;


create or replace function get_discussion_posts (_thread integer, page integer, _limit int, ascending boolean)
returns json as $$
declare
  postdata json;
  total_count int;
begin
  -- get the total count of matching records
  select count(*)
  into total_count
  from discussion_posts_owner po
  where po.thread = _thread;

  -- get the paginated posts
  select json_agg(t)
  into postdata
  from (
    select po.*, get_character_names(po.audience) as audience_names
    from discussion_posts_owner po
    where po.thread = _thread
    order by
      case when ascending then po.created_at end asc,
      case when not ascending then po.created_at end desc
    limit _limit
    offset page * _limit
  ) t;

  -- return the result as json
  return json_build_object(
    'count', total_count,
    'postdata', postdata
  );
end;
$$ language plpgsql;

create or replace function get_discussion_posts_special (user_id uuid, _thread integer, page integer, _limit int)
returns json as $$
declare
  postdata json;
  total_count int;
begin
  -- get the total count of matching records
  select count(*)
  into total_count
  from discussion_posts_owner po
  where po.thread = _thread and (po.owner = user_id or user_id = any (po.audience));

  -- get the paginated posts
  select json_agg(t)
  into postdata
  from (
    select po.*, get_character_names(po.audience) as audience_names
    from discussion_posts_owner po
    where po.thread = _thread and (po.owner = user_id or user_id = any (po.audience))
    order by po.created_at desc
    limit _limit
    offset page * _limit
  ) t;

  -- return the result as json
  return json_build_object(
    'count', total_count,
    'postdata', postdata
  );
end;
$$ language plpgsql;


create or replace function get_game_posts (thread_id integer, game_id integer, owners uuid[], _limit integer, _offset integer, _search text default null)
  returns json as $$
declare
  is_storyteller boolean;
  player_characters uuid[];
  search_lower text;
begin
  -- normalize the search term to lowercase, handling NULL cases
  search_lower := lower(coalesce(_search, ''));

  -- check if the user is a storyteller in this game
  select exists(select 1 from characters where game = game_id and player = auth.uid() and storyteller) into is_storyteller;

  -- get array of player's character ids
  select array_agg(id) into player_characters from characters where game = game_id and player = auth.uid();

  return (
    with filtered_posts as (
      select p.*,
        -- check if a search term is provided, if not, use the original content
        case
          when search_lower = '' then p.content
          else regexp_replace(p.content, '(?i)' || _search, '<span class="highlight">' ||UPPER(_search)||'</span>', 'g')
        end as highlighted_content
      from game_posts_owner p where p.thread = thread_id
      and (
        p.audience is null or is_storyteller or
        (not is_storyteller and (p.audience && player_characters or p.owner = any(player_characters)))
      )
      and (owners is null or p.owner = any(owners))
      -- search content and owner character name
      and (_search is null or (lower(p.content) like '%' || search_lower || '%') or (lower(p.owner_name) like '%' || search_lower || '%'))
    ), ordered_posts as (
      select
        to_jsonb(fp) - 'content' || jsonb_build_object('content', fp.highlighted_content) as post,
        get_character_names(fp.audience) as audience_names
      from filtered_posts fp
      order by fp.created_at desc
      limit _limit offset _offset
    )
    select json_build_object(
      'posts', (select json_agg(op.post || jsonb_build_object('audience_names', op.audience_names)) from ordered_posts op),
      'count', (select count(*) from filtered_posts)
    )
  );
end;
$$ language plpgsql;


create or replace function get_solo_game (solo_id uuid) returns json as $$
declare
  solo_game_var json;
  solo_concept_var json;
  solo_character json;
begin
  select to_jsonb(g) into solo_game_var from solo_games g where g.id = solo_id;
  if not found then return json_build_object('error', 'Solo game not found'); end if;

  select to_jsonb(c) into solo_concept_var from solo_concepts c where c.id = (solo_game_var->>'concept_id')::int;
  if not found then return json_build_object('error', 'Solo concept not found'); end if;

  select to_jsonb(ch) into solo_character from characters ch where ch.solo_game = (solo_game_var->>'id')::uuid and ch.player = (solo_game_var->>'player')::uuid;
  if not found then return json_build_object('error', 'Solo character not found'); end if;

  return json_build_object( 'game', solo_game_var, 'concept', solo_concept_var, 'character', solo_character );
end;
$$ language plpgsql;


create or replace function update_reaction (i_id int4, i_type text, reaction_type text, action text) returns setof reactions as $$
declare
  user_id uuid := auth.uid();
begin
  if action = 'add' then
    return query
    insert into reactions (item_id, item_type, thumbs, frowns, shocks, hearts, laughs)
    values (
      i_id,
      i_type,
      case when reaction_type = 'thumbs' then array[user_id] else '{}' end,
      case when reaction_type = 'frowns' then array[user_id] else '{}' end,
      case when reaction_type = 'shocks' then array[user_id] else '{}' end,
      case when reaction_type = 'hearts' then array[user_id] else '{}' end,
      case when reaction_type = 'laughs' then array[user_id] else '{}' end
    )
    on conflict (item_id, item_type) do update
    set thumbs = case when reaction_type = 'thumbs' and not (user_id = any(reactions.thumbs)) then array_append(reactions.thumbs, user_id) else reactions.thumbs end,
        frowns = case when reaction_type = 'frowns' and not (user_id = any(reactions.frowns)) then array_append(reactions.frowns, user_id) else reactions.frowns end,
        shocks = case when reaction_type = 'shocks' and not (user_id = any(reactions.shocks)) then array_append(reactions.shocks, user_id) else reactions.shocks end,
        hearts = case when reaction_type = 'hearts' and not (user_id = any(reactions.hearts)) then array_append(reactions.hearts, user_id) else reactions.hearts end,
        laughs = case when reaction_type = 'laughs' and not (user_id = any(reactions.laughs)) then array_append(reactions.laughs, user_id) else reactions.laughs end
    returning *;
  elsif action = 'remove' then
    return query
    update reactions
    set thumbs = case when reaction_type = 'thumbs' then array_remove(reactions.thumbs, user_id) else reactions.thumbs end,
        frowns = case when reaction_type = 'frowns' then array_remove(reactions.frowns, user_id) else reactions.frowns end,
        shocks = case when reaction_type = 'shocks' then array_remove(reactions.shocks, user_id) else reactions.shocks end,
        hearts = case when reaction_type = 'hearts' then array_remove(reactions.hearts, user_id) else reactions.hearts end,
        laughs = case when reaction_type = 'laughs' then array_remove(reactions.laughs, user_id) else reactions.laughs end
    where reactions.item_id = i_id and reactions.item_type = i_type
    returning *;
  end if;
end;
$$ language plpgsql;


create or replace function is_mod (board_id int4) returns boolean as $$
begin
  return exists(select 1 from boards where id = board_id and owner = auth.uid() or mods @> array[auth.uid()]);
end;
$$ language plpgsql;


create or replace function is_storyteller (game_id int4) returns boolean as $$
begin
  return exists(select 1 from characters where game = game_id and accepted = true and player = auth.uid() and storyteller);
end;
$$ language plpgsql security definer;


create or replace function is_player (game_id int4) returns boolean as $$
begin
  return exists(select 1 from characters where game = game_id and accepted = true and player = auth.uid());
end;
$$ language plpgsql security definer;


create or replace function is_players_character (character_id uuid) returns boolean as $$
begin
  return exists(select 1 from characters where id = character_id and player = auth.uid());
end;
$$ language plpgsql security definer;


create or replace function is_thread_owner (thread_id int4) returns boolean as $$
select exists (
  select 1 from boards where thread = thread_id and owner = auth.uid()
  union all
  select 1 from games where (discussion_thread = thread_id or game_thread = thread_id) and owner = auth.uid()
  union all
  select 1 from works where thread = thread_id and owner = auth.uid()
);
$$ language sql security definer;


create or replace function get_game_messages_for_user () returns table (
  id integer,
  sender_character uuid,
  recipient_character uuid,
  content text,
  read boolean,
  moderated boolean,
  created_at timestamptz,
  sender_user uuid,
  recipient_user uuid
) as $$
declare
  user_id uuid := auth.uid();
begin
  return query
  select gm.id, gm.sender_character, gm.recipient_character, gm.content, gm.read, gm.moderated, gm.created_at, gm.sender_user, gm.recipient_user
  from game_messages gm
  where gm.sender_user = user_id or gm.recipient_user = user_id;
end;
$$ language plpgsql;


create or replace function get_character_data () returns json as $$
declare
  user_id uuid := auth.uid();
begin
  return (
    with user_games as (
      select c.game
      from characters c
      where c.player = user_id and c.game is not null
      group by c.game
    ),
    all_characters as (
      select
        g.id as game_id,
        g.name as game_name,
        json_agg(
          json_build_object(
            'name', c.name,
            'id', c.id,
            'portrait', c.portrait,
            'state', c.state,
            'player', c.player,
            'storyteller', c.storyteller,
            'game', c.game,
            'unread', (select coalesce(sum((contact->>'unread')::int), 0) from json_array_elements(c.contacts) as contact),
            'contacts', c.contacts,
            'accepted', c.accepted
          ) order by lower(c.name)
        ) as characters
      from user_games ug
      join (
        select
          c.*,
          (
            select json_agg(
              json_build_object(
                'name', other_c.name,
                'id', other_c.id,
                'portrait', other_c.portrait,
                'player', other_c.player,
                'state', other_c.state,
                'storyteller', other_c.storyteller,
                'unread', coalesce((
                  select ucmc.unread_count
                  from unread_character_message_counts ucmc
                  where ucmc.recipient_character_id = c.id and ucmc.sender_character_id = other_c.id
                ), 0),
                'active', (select p.last_activity > current_timestamp - interval '5 minutes' from profiles p where p.id = other_c.player)
              ) order by lower(other_c.name)
            )
            from characters other_c
            where other_c.game = c.game and other_c.id != c.id and other_c.player != c.player -- Ensure other_c.player is not null if it's part of game logic
            and (other_c.state = 'alive' or (other_c.state = 'dead' and ( 
              coalesce((
                select sum(ucmc.unread_count)
                from unread_character_message_counts ucmc
                where (ucmc.recipient_character_id = c.id and ucmc.sender_character_id = other_c.id)
                   or (ucmc.recipient_character_id = other_c.id and ucmc.sender_character_id = c.id)
              ), 0) > 0
            )))
          ) as contacts
        from characters c
        where c.player = user_id and c.state != 'deleted'
      ) c on c.game = ug.game
      join games g on g.id = c.game
      group by g.id, g.name
    ),
    stranded_characters as (
      select json_agg(
        json_build_object(
          'name', c.name,
          'id', c.id,
          'state', c.state,
          'portrait', c.portrait,
          'unread', coalesce((
            select sum(ucmc.unread_count)
            from unread_character_message_counts ucmc
            where ucmc.recipient_character_id = c.id
            ), 0
          )
        ) order by lower(c.name)
      ) as characters
      from characters c
      where c.player = user_id and c.game is null and c.state != 'deleted'
    )
    select json_build_object(
      'allGrouped', (select json_agg(json_build_object('id', game_id, 'name', game_name, 'characters', characters)) from all_characters),
      'myStranded', (select coalesce(characters, '[]'::json) from stranded_characters),
      'unreadTotal', (
        select coalesce(sum((character_data->>'unread')::int),0)
        from (
          select json_array_elements(acc.characters) as character_data from all_characters acc
          union all
          select json_array_elements(coalesce(sc.characters, '[]'::json)) as character_data from stranded_characters sc
        ) as all_unreads
      )
    )
  );
end;
$$ language plpgsql;


create or replace function get_active_user_count () returns integer as $$
begin
  return (select count(*) from profiles where last_activity > now() - interval '5 minutes');
end;
$$ language plpgsql;


create or replace function get_user_data () returns json as $$
declare
  user_uuid uuid := auth.uid();
begin
  return (
    with
      unread_users as (
        select distinct uumc.sender_user_id as id
        from unread_user_message_counts uumc
        where uumc.recipient_user_id = user_uuid and uumc.unread_count > 0
      ),
      contact_ids as (select contact_user as id from public.contacts where owner = user_uuid ),
      active_users as (select id from profiles where last_activity > now() - interval '5 minutes' and id <> user_uuid ),
      candidate as (select id from unread_users union select id from contact_ids union select id from active_users ),
      combined_users as (
        select
          p.id,
          p.name,
          p.portrait,
          exists(select 1 from unread_users u where u.id = p.id) as has_unread,
          exists(select 1 from contact_ids c where c.id = p.id) as contacted,
          p.last_activity > now() - interval '5 minutes' as active,
          coalesce((
            select uumc.unread_count
            from unread_user_message_counts uumc
            where uumc.sender_user_id = p.id and uumc.recipient_user_id = user_uuid
          ), 0) as unread
        from profiles p
        join candidate c on c.id = p.id
      )
    select
      json_agg(
        json_build_object(
          'id',         cu.id,
          'name',       cu.name,
          'portrait',   cu.portrait,
          'has_unread', cu.has_unread,
          'contacted',  cu.contacted,
          'active',     cu.active,
          'unread',     cu.unread
        )
        order by cu.unread desc, cu.active desc, lower(cu.name)
      )
    from combined_users cu
  );
end;
$$ language plpgsql;


create or replace function get_game (game_id int) returns jsonb as $$
declare
  game_data jsonb;
  character_data jsonb;
  map_data jsonb;
  unread_data jsonb;
  codex_data jsonb;
  subscription_data jsonb;
  game_unread_count int;
  discussion_unread_count int;
  current_user_id uuid := auth.uid();
  v_game_thread_id int;
  v_discussion_thread_id int;
begin
  select to_jsonb(t) into game_data from (select g.*, p as owner, m as active_map from games g left join profiles p on g.owner = p.id left join maps m on g.active_map = m.id where g.id = game_id) t;

  -- Extract thread IDs from game_data
  v_game_thread_id := (game_data->>'game_thread')::int;
  v_discussion_thread_id := (game_data->>'discussion_thread')::int;

  -- Inline get_game_unread logic
  select ut.unread_count into game_unread_count
  from unread_threads ut
  where ut.user_id = current_user_id and ut.thread_id = v_game_thread_id;

  select ut.unread_count into discussion_unread_count
  from unread_threads ut
  where ut.user_id = current_user_id and ut.thread_id = v_discussion_thread_id;

  unread_data := jsonb_build_object(
    'gameChat', coalesce(discussion_unread_count, 0),
    'gameThread', coalesce(game_unread_count, 0)
  );

  select jsonb_agg(t) into character_data from (select c.*, p as player from characters c left join profiles p on c.player = p.id where c.game = game_id) t;
  select jsonb_agg(t) into map_data from (select * from maps where game = game_id order by updated_at desc) t;
  select jsonb_agg(t) into codex_data from (select * from codex_sections where game = game_id order by index) t;
  select to_jsonb(t) into subscription_data from (select * from subscriptions where user_id = auth.uid() and game = game_id) t;

  return game_data || jsonb_build_object('characters', character_data, 'maps', map_data, 'unread', unread_data, 'codexSections', codex_data, 'subscription', subscription_data);
end;
$$ language plpgsql;


create or replace function get_notification_data (post_id int) returns jsonb as $$
declare
  game_id int;
  post_owner_user_id uuid;
  is_public boolean;
  audience uuid[];
  user_ids uuid[];
  user_data jsonb;
begin
  -- Retrieve game ID, audience, and the owner's user ID based on the character who owns the post
  select c.game, p.audience, c.player into game_id, audience, post_owner_user_id
  from posts p
  join characters c on c.id = p.owner
  where p.id = post_id and p.owner_type = 'character';

  -- RAISE log 'Game ID: %, Audience: %, Post Owner User ID: %', game_id, audience, post_owner_user_id;

  -- If no game_id was set, it means the post owner_type isn't 'character'
  if game_id is null then
    -- RAISE log 'Exiting because game_id is null.';
    return '[]'::jsonb;
  end if;

  -- Check if the post is public
  is_public := (audience is null);

  if is_public then
    -- Fetch all player IDs for a public post
    select array_agg(distinct c.player) into user_ids from characters c
    where c.game = game_id;
    -- RAISE log 'User IDs for public post: %', user_ids;
  else
    -- Fetch player IDs based on specified character IDs in the audience
    select array_agg(distinct c.player) into user_ids from characters c
    where c.id = any(audience);
    -- RAISE log 'User IDs for specified audience: %', user_ids;
  end if;

  -- Fetch user notification preferences and contact details
  select jsonb_agg(jsonb_build_object('user_id', pr.id, 'name', pr.name, 'notification', s.notification, 'email', s.email, 'email_address', au.email))
  into user_data
  from profiles pr
  join auth.users au on pr.id = au.id
  join subscriptions s on pr.id = s.user_id
  where pr.id = any(user_ids) and pr.id != post_owner_user_id and
        (pr.last_activity is null or pr.last_activity < now() - interval '5 minutes') and
        s.game = game_id
  group by pr.id, s.notification, s.email, au.email;

  -- RAISE log 'Final user data: %', user_data;

  return coalesce(user_data, '[]'::jsonb);
end;
$$ language plpgsql security definer;


create or replace function delete_my_character (character_id uuid)
returns void as $$
begin
  -- first, try to update characters that are part of a game
  update characters set game = null, player = null where id = character_id and player = (select auth.uid()) and game is not null;
  -- if the character was not part of a game, attempt to delete it
  if not found then
    delete from characters
    where id = character_id and player = (select auth.uid()) and game is null;
    if not found then raise exception 'you do not have permission to delete this character.'; end if;
  end if;
end;
$$ language plpgsql security definer;


create or replace function delete_old_chat_posts () returns void as $$
begin
  delete from posts where id not in (select id from posts where thread = 1 order by created_at desc limit 100) and thread = 1;
end;
$$ language plpgsql;


create or replace function thread_read (p_user_id uuid, p_thread_id int4) returns void as $$
begin
  insert into read_threads (user_id, thread_id, read_at)
    values (p_user_id, p_thread_id, now())
    on conflict (user_id, thread_id) do update set read_at = now();

  insert into unread_threads (user_id, thread_id, unread_count)
    values (p_user_id, p_thread_id, 0)
    on conflict (user_id, thread_id) do update set unread_count = 0;
end;
$$ language plpgsql;


create or replace function update_updated_at () returns trigger as $$
begin
  new.updated_at := current_timestamp;
  return new;
end;
$$ language plpgsql;


create or replace function update_post_updated_at() returns trigger as $$
begin
  if new.content is distinct from old.content then
    new.updated_at := current_timestamp;
  end if;
  return new;
end;
$$ language plpgsql;


create or replace function add_default_bookmarks () returns trigger as $$
begin
  insert into bookmarks (user_id, board_id, board_thread)
  select new.id, b.id, b.thread from boards b where b.id = 1;
  insert into bookmarks (user_id, board_id, board_thread)
  select new.id, b.id, b.thread from boards b where b.id = 2;
  insert into bookmarks (user_id, board_id, board_thread)
  select new.id, b.id, b.thread from boards b where b.id = 3;
  return new;
end;
$$ language plpgsql;


create or replace function get_user_names (ids uuid[]) returns jsonb as $$
begin
  return (select jsonb_agg(jsonb_build_object('id', p.id, 'name', p.name)) from profiles p where p.id = any(ids));
end;
$$ language plpgsql;


create or replace function delete_user () returns void as $$
  delete from auth.users where id = auth.uid();
$$ language sql security definer;


create or replace function get_old_chars_by_game (game_id_param bigint)
returns setof old_chars as $$
begin
  return query 
    -- current chars
    select oc.* from old_chars oc where oc.game_id = game_id_param
  union
    -- all chars that wrote at least 1 post
    select oc.* from old_chars oc
    join (
      select distinct id_from  from old_posts where game_id = game_id_param
    ) op on oc.id_char = op.id_from;
end;
$$ language plpgsql security definer;


create or replace function check_if_transferable (character_id uuid) returns boolean as $$
begin
  -- check if character belongs to owner and not being transferred already
  return exists (
    select 1 from characters where id = character_id and player = auth.uid() and transfer_to is null
  );
end;
$$ language plpgsql;


create or replace function transfer_character (character_id uuid) returns boolean as $$
begin
  update characters set player = auth.uid(), transfer_to = null, open = false where id = character_id and transfer_to = auth.uid();
  return found;
end;
$$ language plpgsql security definer;


create or replace function reject_transfer (character_id uuid) returns boolean as $$
begin
  update characters set transfer_to = null, open = false where id = character_id and transfer_to = auth.uid();
  return found;
end;
$$ language plpgsql security definer;


create or replace function update_transfer_message (character_id uuid, game_id integer, new_content text) returns boolean as $$
begin
  update messages
  set content = (
    select case
      when content like '%' || '/api/game/acceptCharacter?gameId=' || game_id || '&characterId=' || character_id || '%' then
        concat(SPLIT_PART(content, '<br>', 1), '<br>' || new_content)
        else content
      end )
    where content like '%' || '/api/game/acceptCharacter?gameId=' || game_id || '&characterId=' || character_id || '%';
  return found;
end;
$$ language plpgsql security definer;


create or replace function add_contact_before_message () returns trigger as $$
begin
  if new.sender_user is not null
     and new.recipient_user is not null
     and new.sender_user <> new.recipient_user
  then
    insert into public.contacts(owner, contact_user)
      values (new.sender_user,    new.recipient_user)
      on conflict do nothing;
    insert into public.contacts(owner, contact_user)
      values (new.recipient_user, new.sender_user)
      on conflict do nothing;
  end if;
  return new;
end;
$$ language plpgsql security definer;


-- Functions and Triggers for Message Unread Counts


create or replace function increment_unread_user_message_count () returns trigger as $$
begin
  if new.recipient_user is not null and new.sender_user is not null then
    insert into unread_user_message_counts (recipient_user_id, sender_user_id, unread_count)
    values (new.recipient_user, new.sender_user, 1)
    on conflict (recipient_user_id, sender_user_id) do update
    set unread_count = unread_user_message_counts.unread_count + 1;
  end if;
  return new;
end;
$$ language plpgsql;


create or replace function decrement_unread_user_message_count () returns trigger as $$
declare
  v_user_read_at timestamp with time zone;
begin
  if old.recipient_user is not null and old.sender_user is not null then
    select ruc.read_at into v_user_read_at
    from read_user_conversations ruc
    where ruc.reader_user_id = old.recipient_user and ruc.peer_user_id = old.sender_user;

    if v_user_read_at is null or old.created_at > v_user_read_at then
      update unread_user_message_counts
      set unread_count = greatest(0, unread_user_message_counts.unread_count - 1)
      where recipient_user_id = old.recipient_user
        and sender_user_id = old.sender_user;
    end if;
  end if;
  return old;
end;
$$ language plpgsql;


create or replace function increment_unread_character_message_count () returns trigger as $$
begin
  if new.recipient_character is not null and new.sender_character is not null then
    insert into unread_character_message_counts (recipient_character_id, sender_character_id, unread_count)
    values (new.recipient_character, new.sender_character, 1)
    on conflict (recipient_character_id, sender_character_id) do update
    set unread_count = unread_character_message_counts.unread_count + 1;
  end if;
  return new;
end;
$$ language plpgsql;


create or replace function decrement_unread_character_message_count () returns trigger as $$
declare
  v_char_read_at timestamp with time zone;
begin
  if old.recipient_character is not null and old.sender_character is not null then
    select rcc.read_at into v_char_read_at
    from read_character_conversations rcc
    where rcc.reader_character_id = old.recipient_character and rcc.peer_character_id = old.sender_character;

    if v_char_read_at is null or old.created_at > v_char_read_at then
      update unread_character_message_counts
      set unread_count = greatest(0, unread_character_message_counts.unread_count - 1)
      where recipient_character_id = old.recipient_character
        and sender_character_id = old.sender_character;
    end if;
  end if;
  return old;
end;
$$ language plpgsql;


-- TRIGGERS --------------------------------------------


create or replace trigger add_default_bookmarks after insert on profiles for each row execute function add_default_bookmarks();
-- Triggers for games
create or replace trigger update_map_updated_at before update on maps for each row execute procedure update_updated_at();
create or replace trigger add_storyteller after insert on games for each row execute function add_storyteller();
create or replace trigger add_codex_index after insert on games for each row execute function add_codex_index();
create or replace trigger update_codex_updated_at before update on codex_pages for each row execute procedure update_updated_at();
create or replace trigger add_game_threads before insert on games for each row execute function add_game_threads();
create or replace trigger delete_game_threads after delete on games for each row execute procedure delete_game_threads();
-- Triggers for boards
create or replace trigger add_board_thread before insert on boards for each row execute function add_thread();
create or replace trigger delete_board_thread after delete on boards for each row execute procedure delete_thread();
-- Triggers for solo games
create or replace trigger add_solo_game_thread before insert on solo_games for each row execute function add_thread();
create or replace trigger update_solo_concept_updated_at before update on solo_concepts for each row execute procedure update_updated_at();
-- Triggers for works
create or replace trigger add_work_thread before insert on works for each row execute function add_thread();
create or replace trigger delete_work_thread after delete on works for each row execute procedure delete_thread();
-- Triggers for posts and messages
create or replace trigger update_post_updated_at before update on posts for each row execute procedure update_post_updated_at();
create or replace trigger update_message_updated_at before update on messages for each row execute procedure update_updated_at();
create or replace trigger ensure_contact before insert on messages for each row execute function add_contact_before_message();
-- Triggers for thread unread counts
create or replace trigger increment_unread_after_post_insert after insert on posts for each row execute function increment_unread_counters();
create or replace trigger decrement_unread_after_post_delete after delete on posts for each row execute procedure decrement_unread_counters();
-- Triggers for user message unread counts
create or replace trigger increment_user_message_unread after insert on messages for each row when (new.recipient_user is not null and new.sender_user is not null and new.sender_character is null and new.recipient_character is null) execute procedure increment_unread_user_message_count();
create or replace trigger decrement_user_message_unread_on_delete after delete on messages for each row when (old.recipient_user is not null and old.sender_user is not null and old.sender_character is null and old.recipient_character is null) execute procedure decrement_unread_user_message_count();
-- Triggers for character message unread counts
create or replace trigger increment_character_message_unread after insert on messages for each row when (new.recipient_character is not null and new.sender_character is not null) execute procedure increment_unread_character_message_count();
create or replace trigger decrement_character_message_unread_on_delete after delete on messages for each row when (old.recipient_character is not null and old.sender_character is not null) execute procedure decrement_unread_character_message_count();


-- WEBHOOKS --------------------------------------------


create trigger notify after insert on public.posts for each row
execute function supabase_functions.http_request (
  'https://zwclrcefxleqmzhhfcte.supabase.co/functions/v1/notify', 'POST', '{ "Content-Type":"application/json" }', '{}', '1000'
);


-- STORAGE  --------------------------------------------


insert into storage.buckets (id, name, public) values ('headers', 'headers', true);
insert into storage.buckets (id, name, public) values ('portraits', 'portraits', true);
insert into storage.buckets (id, name, public) values ('posts', 'posts', true);
insert into storage.buckets (id, name, public) values ('maps', 'maps', true);
insert into storage.buckets (id, name, public) values ('works', 'works', true);
insert into storage.buckets (id, name, public) values ('news', 'news', true);
insert into storage.buckets (id, name, public) values ('npcs', 'npcs', true);
insert into storage.buckets (id, name, public) values ('scenes', 'scenes', true);
insert into storage.buckets (id, name, public) values ('items', 'items', true);


-- SEED  --------------------------------------------


-- Run as a user session, or replace auth.uid() with a user id
-- Disable the trigger "add_default_bookmarks" to create a user manually in the profiles table.

insert into threads (name) values ('Chat'); -- has to be ID 1
insert into public.boards (name, owner) values ('Nápověda', auth.uid())
insert into public.boards (name, owner) values ('Správa Andoru', auth.uid())
insert into public.boards (name, owner) values ('Nahlášení obsahu', auth.uid())
insert into public.boards (id, name, owner) values (999, 'Tvorba', auth.uid())
