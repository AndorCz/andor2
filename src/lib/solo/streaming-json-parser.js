/**
 * A streaming JSON parser specifically designed for extracting and streaming
 * partial content from JSON as it's being generated by AI models.
 */
export class StreamingJSONParser {
  constructor() {
    this.buffer = ''
    this.characterSent = false
    this.lastPostLength = 0
    this.postStartIndex = -1
    this.postContentStart = -1
    this.events = []
  }

  /**
   * Process a new chunk of text from the stream
   * Returns an array of events to yield
   */
  processChunk(chunk) {
    this.buffer += chunk
    this.events = []
    
    // Extract character data first
    if (!this.characterSent) {
      this.extractCharacter()
    }
    
    // Stream post content if character has been sent
    if (this.characterSent) {
      this.streamPostContent()
    }
    
    return this.events
  }

  /**
   * Extract character information from the buffer
   */
  extractCharacter() {
    const charMatch = this.buffer.match(/"character"\s*:\s*\{[^}]*"slug"\s*:\s*"([^"]*)"/)
    if (charMatch) {
      this.events.push({ character: { slug: charMatch[1] } })
      this.characterSent = true
    }
  }

  /**
   * Stream post content incrementally
   */
  streamPostContent() {
    // Find post start if not already found
    if (this.postStartIndex === -1) {
      this.postStartIndex = this.buffer.indexOf('"post"')
      if (this.postStartIndex === -1) return
    }

    // Find the opening quote of the post content
    if (this.postContentStart === -1) {
      const colonIndex = this.buffer.indexOf(':', this.postStartIndex)
      if (colonIndex !== -1) {
        this.postContentStart = this.buffer.indexOf('"', colonIndex)
        if (this.postContentStart === -1) return
        this.postContentStart += 1 // Skip the opening quote
      } else {
        return
      }
    }

    // Extract the current post content
    const postContent = this.extractJSONStringContent(this.postContentStart)
    
    // Send only new content
    if (postContent.length > this.lastPostLength) {
      const newContent = postContent.slice(this.lastPostLength)
      if (newContent.length > 0) {
        const cleanContent = this.unescapeJSONString(newContent)
        this.events.push({ post: cleanContent })
        this.lastPostLength = postContent.length
      }
    }
  }

  /**
   * Extract JSON string content from a starting position, handling escapes
   */
  extractJSONStringContent(startIndex) {
    let content = ''
    let i = startIndex
    let escaped = false
    
    while (i < this.buffer.length) {
      const char = this.buffer[i]
      
      if (escaped) {
        content += char
        escaped = false
      } else if (char === '\\') {
        content += char
        escaped = true
      } else if (char === '"') {
        // Found the closing quote
        break
      } else {
        content += char
      }
      i++
    }
    
    return content
  }

  /**
   * Unescape JSON string content for display
   */
  unescapeJSONString(str) {
    return str
      .replace(/\\"/g, '"')
      .replace(/\\n/g, '\n')
      .replace(/\\t/g, '\t')
      .replace(/\\r/g, '\r')
      .replace(/\\\\/g, '\\')
  }

  /**
   * Finalize parsing and return the complete data
   */
  finalize() {
    try {
      const finalData = JSON.parse(this.buffer)
      return finalData
    } catch (error) {
      console.error('Error parsing final JSON:', error)
      console.log('Buffer content:', this.buffer)
      throw error
    }
  }
}
