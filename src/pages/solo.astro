---
	import Layout from '@layouts/layout.astro'
  import SoloList from '@components/solo/SoloList.svelte'

  const { supabase, user, runtime } = Astro.locals
  const limit = 20

  const sort = Astro.url.searchParams.get('sort') || 'popular'
  const searchTerm = (Astro.url.searchParams.get('search') || '').trim()

  let page = Number.parseInt(Astro.url.searchParams.get('page') || '0', 10)
  if (Number.isNaN(page) || page < 0) { page = 0 }

  function createBaseQuery () {
    return supabase.from('solo_concepts').select('*, author: profiles(id, name, portrait)', { count: 'exact' }).match({published: true })
  }

  function applySort (query) {
    switch (sort) {
      case 'name': return query.order('name')
      case 'new': return query.order('created_at', { ascending: false })
      case 'games': return query.order('game_count', { ascending: false })
      case 'author': return query.order('author')
      default: return query.order('game_count', { ascending: false })
    }
  }

  let concepts = []
  let count = 0
  let error
  let maxPage = 0

  if (searchTerm) {
    const likeTerm = `%${searchTerm}%`
    const { data: nameMatches = [], error: nameError } = await createBaseQuery().ilike('name', likeTerm)
    const { data: annotationMatches = [], error: annotationError } = await createBaseQuery().ilike('annotation', likeTerm)

    error = nameError || annotationError

    const lowerTerm = searchTerm.toLowerCase()
    const sortByMatch = (collection, field) => {
      return [...collection].sort((a, b) => {
        const aValue = (a[field] || '').toLowerCase()
        const bValue = (b[field] || '').toLowerCase()
        const aIndex = aValue.indexOf(lowerTerm)
        const bIndex = bValue.indexOf(lowerTerm)
        if (aIndex === bIndex) { return aValue.localeCompare(bValue, 'cs') }
        return aIndex - bIndex
      })
    }

    const orderedNameMatches = sortByMatch(nameMatches, 'name')
    const orderedAnnotationMatches = sortByMatch(annotationMatches, 'annotation')

    const uniqueConcepts = new Map()
    for (const concept of orderedNameMatches) { uniqueConcepts.set(concept.id, concept) }
    for (const concept of orderedAnnotationMatches) { if (!uniqueConcepts.has(concept.id)) { uniqueConcepts.set(concept.id, concept) } }

    concepts = Array.from(uniqueConcepts.values())
    count = concepts.length
    page = 0
    maxPage = 0
  } else {
    const rangeStart = page * limit
    const rangeEnd = rangeStart + limit - 1
    const { data, count: total, error: queryError } = await applySort(createBaseQuery()).range(rangeStart, rangeEnd)
    concepts = data || []
    count = total ?? 0
    error = queryError
    maxPage = count > 0 ? Math.ceil(count / limit) - 1 : 0
  }

  if (error) { console.error(error) }
---
<Layout title='Solo'>
  <SoloList {user} {concepts} {page} {maxPage} showHeadline searchTerm={searchTerm} client:only='svelte' />
</Layout>